diff --git a/src/ray/core_worker/transport/direct_task_transport.cc b/src/ray/core_worker/transport/direct_task_transport.cc
index 5e0aa8dcd..e3b9e5d56 100644
--- a/src/ray/core_worker/transport/direct_task_transport.cc
+++ b/src/ray/core_worker/transport/direct_task_transport.cc
@@ -35,7 +35,6 @@ void CoreWorkerDirectTaskSubmitter::AddWorkerLeaseClient(
 void CoreWorkerDirectTaskSubmitter::OnWorkerIdle(const rpc::WorkerAddress &addr,
                                                  const TaskQueueKey &queue_key,
                                                  bool was_error) {
-  absl::MutexLock lock(&mu_);
   auto lease_entry = worker_to_lease_client_[addr];
   auto queue_entry = task_queues_.find(queue_key);
   // Return the worker if there was an error executing the previous task,
@@ -138,7 +137,10 @@ void CoreWorkerDirectTaskSubmitter::PushNormalTask(const rpc::WorkerAddress &add
   auto status = client.PushNormalTask(
       std::move(request), [this, task_id, queue_key, num_returns, addr](
                               Status status, const rpc::PushTaskReply &reply) {
-        OnWorkerIdle(addr, queue_key, /*error=*/!status.ok());
+        {
+          absl::MutexLock lock(&mu_);
+          OnWorkerIdle(addr, queue_key, /*error=*/!status.ok());
+        }
         if (!status.ok()) {
           TreatTaskAsFailed(task_id, num_returns, rpc::ErrorType::WORKER_DIED,
                             in_memory_store_);
diff --git a/src/ray/core_worker/transport/direct_task_transport.h b/src/ray/core_worker/transport/direct_task_transport.h
index fdd575ce8..84b4f1ccf 100644
--- a/src/ray/core_worker/transport/direct_task_transport.h
+++ b/src/ray/core_worker/transport/direct_task_transport.h
@@ -45,7 +45,7 @@ class CoreWorkerDirectTaskSubmitter {
   /// no more tasks are queued for submission. If an error was encountered
   /// processing the worker, we don't attempt to re-use the worker.
   void OnWorkerIdle(const rpc::WorkerAddress &addr, const TaskQueueKey &task_queue_key,
-                    bool was_error);
+                    bool was_error) EXCLUSIVE_LOCKS_REQUIRED(mu_);
 
   /// Get an existing lease client or connect a new one. If a raylet_address is
   /// provided, this connects to a remote raylet. Else, this connects to the
