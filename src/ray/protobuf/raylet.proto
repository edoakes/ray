syntax = "proto3";

package ray.rpc;

import "src/ray/protobuf/common.proto";
import "src/ray/protobuf/gcs.proto";

/// NOTE(Joey Jiang) Every request defined in this file should have a `worker_id` field,
/// which will be used in `NodeManager::PreprocessRequest`.

enum MessageType {
  None = 0;
  RegisterClient = 100;
  DisconnectClient = 101;
  SubmitTask = 102;
  GetTask = 103;
}

/// Service request and reply messages.
message RegisterClientRequest {
  // The worker id.
  bytes worker_id = 1;
  // Indicates the client is a worker or a driver.
  bool is_worker = 2;
  // The process ID of this worker.
  uint32 worker_pid = 3;
  // The job ID.
  bytes job_id = 4;
  // Language of this worker.
  Language language = 5;
  // Port that this worker is listening on.
  // If port > 0, then worker will listen to this port and wait for
  // raylet to push tasks, instead of invoking GetTask().
  int32 port = 6;
}

message SubmitTaskRequest {
  bytes worker_id = 1;
  TaskSpec task_spec = 2;
}

message DisconnectClientRequest {
  bytes worker_id = 1;
}

message GetTaskRequest {
  bytes worker_id = 1;
}
message GetTaskReply {
  // A string of bytes representing the task specification.
  bytes task_spec = 1;
  // A list of the resources reserved for this worker.
  repeated ResourceIdSetInfo fractional_resource_ids = 2;
}

message TaskDoneRequest {
  bytes worker_id = 1;
}

message FetchOrReconstructRequest {
  // The worker ID.
  bytes worker_id = 1;
  // List of object IDs of the objects that we want to reconstruct or fetch.
  repeated bytes object_ids = 2;
  // Indicates that we only want to fetch objects, not reconstruct them.
  bool fetch_only = 3;
  // The current task ID. If fetch_only is false, then this task is blocked.
  bytes task_id = 4;
}

message NotifyUnblockedRequest {
  bytes worker_id = 1;
  // The current task ID. This task is no longer blocked.
  bytes task_id = 2;
}

message WaitRequest {
  // The worker ID.
  bytes worker_id = 1;
  // List of object ids we'll be waiting on.
  repeated bytes object_ids = 2;
  // Number of objects expected to be returned, if available.
  uint64 num_ready_objects = 3;
  // Timeout in milliseconds.
  int64 timeout = 4;
  // Whether to wait until objects appear locally.
  bool wait_local = 5;
  // The current task ID. If there are less than num_ready_objects local, then
  // this task is blocked.
  bytes task_id = 6;
}
message WaitReply {
  // List of object ids found.
  repeated bytes found = 1;
  // List of object ids not found.
  repeated bytes remaining = 2;
}

message PushErrorRequest {
  // The worker ID.
  bytes worker_id = 1;
  // The job id that the error is for.
  bytes job_id = 2;
  // The type of the error.
  bytes type = 3;
  // The error message.
  bytes error_message = 4;
  // The timestamp of the error message.
  double timestamp = 5;
}

message PushProfileEventsRequest {
  bytes worker_id = 1;
  ProfileTableData profile_table_data = 2;
}

message FreeObjectsInStoreRequest {
  // The worker ID.
  bytes worker_id = 1;
  // Whether keep this request within the local object store
  // or send it to all of the object stores.
  bool local_only = 2;
  // Whether also delete objects' creating tasks from GCS.
  bool delete_creating_tasks = 3;
  // List of object ids to delete from the object store.
  repeated bytes object_ids = 4;
}

message PrepareActorCheckpointRequest {
  bytes worker_id = 1;
  bytes actor_id = 2;
}
message PrepareActorCheckpointReply {
  bytes worker_id = 1;
  bytes checkpoint_id = 2;
}

message NotifyActorResumedFromCheckpointRequest {
  bytes worker_id = 1;
  // ID of the actor that resumed.
  bytes actor_id = 2;
  // ID of the checkpoint from which the actor was resumed.
  bytes checkpoint_id = 3;
}

message SetResourceRequest {
  bytes worker_id = 1;
  // Name of the resource to be set.
  bytes resource_name = 2;
  // Capacity of the resource to be set.
  double capacity = 3;
  // Client ID where this resource will be set.
  bytes client_id = 4;
}

message HeartbeatRequest {
  bytes worker_id = 1;
  bool is_worker = 2;
}
